12a13
> #include "pycore_emscripten_trampoline.h" // _PyCFunction_TrampolineCall()
17,26c18,36
< #define _PyObject_IMMORTAL_INIT(type) \
<     { \
<         .ob_refcnt = 999999999, \
<         .ob_type = type, \
<     }
< #define _PyVarObject_IMMORTAL_INIT(type, size) \
<     { \
<         .ob_base = _PyObject_IMMORTAL_INIT(type), \
<         .ob_size = size, \
<     }
---
> /* We need to maintain an internal copy of Py{Var}Object_HEAD_INIT to avoid
>    designated initializer conflicts in C++20. If we use the deinition in
>    object.h, we will be mixing designated and non-designated initializers in
>    pycore objects which is forbiddent in C++20. However, if we then use
>    designated initializers in object.h then Extensions without designated break.
>    Furthermore, we can't use designated initializers in Extensions since these
>    are not supported pre-C++20. Thus, keeping an internal copy here is the most
>    backwards compatible solution */
> #define _PyObject_HEAD_INIT(type)         \
>     {                                     \
>         _PyObject_EXTRA_INIT              \
>         .ob_refcnt = _Py_IMMORTAL_REFCNT, \
>         .ob_type = (type)                 \
>     },
> #define _PyVarObject_HEAD_INIT(type, size)    \
>     {                                         \
>         .ob_base = _PyObject_HEAD_INIT(type)  \
>         .ob_size = size                       \
>     },
32c42,43
< #define _Py_FatalRefcountError(message) _Py_FatalRefcountErrorFunc(__func__, message)
---
> #define _Py_FatalRefcountError(message) \
>     _Py_FatalRefcountErrorFunc(__func__, (message))
33a45,94
> 
> #ifdef Py_REF_DEBUG
> /* The symbol is only exposed in the API for the sake of extensions
>    built against the pre-3.12 stable ABI. */
> PyAPI_DATA(Py_ssize_t) _Py_RefTotal;
> 
> extern void _Py_AddRefTotal(PyInterpreterState *, Py_ssize_t);
> extern void _Py_IncRefTotal(PyInterpreterState *);
> extern void _Py_DecRefTotal(PyInterpreterState *);
> 
> #  define _Py_DEC_REFTOTAL(interp) \
>     interp->object_state.reftotal--
> #endif
> 
> // Increment reference count by n
> static inline void _Py_RefcntAdd(PyObject* op, Py_ssize_t n)
> {
>     if (_Py_IsImmortal(op)) {
>         return;
>     }
> #ifdef Py_REF_DEBUG
>     _Py_AddRefTotal(_PyInterpreterState_GET(), n);
> #endif
>     op->ob_refcnt += n;
> }
> #define _Py_RefcntAdd(op, n) _Py_RefcntAdd(_PyObject_CAST(op), n)
> 
> static inline void _Py_SetImmortal(PyObject *op)
> {
>     if (op) {
>         op->ob_refcnt = _Py_IMMORTAL_REFCNT;
>     }
> }
> #define _Py_SetImmortal(op) _Py_SetImmortal(_PyObject_CAST(op))
> 
> /* _Py_ClearImmortal() should only be used during runtime finalization. */
> static inline void _Py_ClearImmortal(PyObject *op)
> {
>     if (op) {
>         assert(op->ob_refcnt == _Py_IMMORTAL_REFCNT);
>         op->ob_refcnt = 1;
>         Py_DECREF(op);
>     }
> }
> #define _Py_ClearImmortal(op) \
>     do { \
>         _Py_ClearImmortal(_PyObject_CAST(op)); \
>         op = NULL; \
>     } while (0)
> 
36a98,101
>     if (_Py_IsImmortal(op)) {
>         return;
>     }
>     _Py_DECREF_STAT_INC();
38c103
<     _Py_RefTotal--;
---
>     _Py_DEC_REFTOTAL(_PyInterpreterState_GET());
53a119,122
>     if (_Py_IsImmortal(op)) {
>         return;
>     }
>     _Py_DECREF_STAT_INC();
55c124
<     _Py_RefTotal--;
---
>     _Py_DEC_REFTOTAL(_PyInterpreterState_GET());
64a134,138
> #ifdef Py_REF_DEBUG
> #  undef _Py_DEC_REFTOTAL
> #endif
> 
> 
81a156
> extern void _PyObject_InitState(PyInterpreterState *interp);
103c178
<     Py_SET_SIZE(op, size);
---
>     assert(typeobj != &PyLong_Type);
104a180
>     Py_SET_SIZE(op, size);
192a269,270
> extern void _PyInterpreterState_FinalizeRefTotal(PyInterpreterState *);
> extern void _Py_FinalizeRefTotal(_PyRuntimeState *);
198,199c276,277
< extern void _Py_PrintReferences(FILE *);
< extern void _Py_PrintReferenceAddresses(FILE *);
---
> extern void _Py_PrintReferences(PyInterpreterState *, FILE *);
> extern void _Py_PrintReferenceAddresses(PyInterpreterState *, FILE *);
201a280,289
> 
> /* Return the *address* of the object's weaklist.  The address may be
>  * dereferenced to get the current head of the weaklist.  This is useful
>  * for iterating over the linked list of weakrefs, especially when the
>  * list is being modified externally (e.g. refs getting removed).
>  *
>  * The returned pointer should not be used to change the head of the list
>  * nor should it be used to add, remove, or swap any refs in the list.
>  * That is the sole responsibility of the code in weakrefobject.c.
>  */
204a293,300
>     if (PyType_Check(op) &&
>             ((PyTypeObject *)op)->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {
>         PyInterpreterState *interp = _PyInterpreterState_GET();
>         static_builtin_state *state = _PyStaticType_GetState(
>                                                 interp, (PyTypeObject *)op);
>         return _PyStaticType_GET_WEAKREFS_LISTPTR(state);
>     }
>     // Essentially _PyObject_GET_WEAKREFS_LISTPTR_FROM_OFFSET():
208a305,326
> /* This is a special case of _PyObject_GET_WEAKREFS_LISTPTR().
>  * Only the most fundamental lookup path is used.
>  * Consequently, static types should not be used.
>  *
>  * For static builtin types the returned pointer will always point
>  * to a NULL tp_weaklist.  This is fine for any deallocation cases,
>  * since static types are never deallocated and static builtin types
>  * are only finalized at the end of runtime finalization.
>  *
>  * If the weaklist for static types is actually needed then use
>  * _PyObject_GET_WEAKREFS_LISTPTR().
>  */
> static inline PyWeakReference **
> _PyObject_GET_WEAKREFS_LISTPTR_FROM_OFFSET(PyObject *op)
> {
>     assert(!PyType_Check(op) ||
>             ((PyTypeObject *)op)->tp_flags & Py_TPFLAGS_HEAPTYPE);
>     Py_ssize_t offset = Py_TYPE(op)->tp_weaklistoffset;
>     return (PyWeakReference **)((char *)op + offset);
> }
> 
> 
225c343
<         _PyType_HasFeature(tp, Py_TPFLAGS_MANAGED_DICT) * 2 * sizeof(PyObject *);
---
>         _PyType_HasFeature(tp, Py_TPFLAGS_PREHEADER) * 2 * sizeof(PyObject *);
236,239d353
< // PyType_Ready() must be called if _PyType_IsReady() is false.
< // See also the Py_TPFLAGS_READY flag.
< #define _PyType_IsReady(type) ((type)->tp_dict != NULL)
< 
242c356
<     return (type->tp_weaklistoffset > 0);
---
>     return (type->tp_weaklistoffset != 0);
253c367,374
< static inline PyDictValues **_PyObject_ValuesPointer(PyObject *obj)
---
> typedef union {
>     PyObject *dict;
>     /* Use a char* to generate a warning if directly assigning a PyDictValues */
>     char *values;
> } PyDictOrValues;
> 
> static inline PyDictOrValues *
> _PyObject_DictOrValuesPointer(PyObject *obj)
256c377
<     return ((PyDictValues **)obj)-4;
---
>     return ((PyDictOrValues *)obj)-3;
259c380,381
< static inline PyObject **_PyObject_ManagedDictPointer(PyObject *obj)
---
> static inline int
> _PyDictOrValues_IsValues(PyDictOrValues dorv)
261,262c383
<     assert(Py_TYPE(obj)->tp_flags & Py_TPFLAGS_MANAGED_DICT);
<     return ((PyObject **)obj)-3;
---
>     return ((uintptr_t)dorv.values) & 1;
265c386,391
< #define MANAGED_DICT_OFFSET (((int)sizeof(PyObject *))*-3)
---
> static inline PyDictValues *
> _PyDictOrValues_GetValues(PyDictOrValues dorv)
> {
>     assert(_PyDictOrValues_IsValues(dorv));
>     return (PyDictValues *)(dorv.values + 1);
> }
267,272c393,398
< extern PyObject ** _PyObject_DictPointer(PyObject *);
< extern int _PyObject_VisitInstanceAttributes(PyObject *self, visitproc visit, void *arg);
< extern void _PyObject_ClearInstanceAttributes(PyObject *self);
< extern void _PyObject_FreeInstanceAttributes(PyObject *self);
< extern int _PyObject_IsInstanceDictEmpty(PyObject *);
< extern PyObject* _PyType_GetSubclasses(PyTypeObject *);
---
> static inline PyObject *
> _PyDictOrValues_GetDict(PyDictOrValues dorv)
> {
>     assert(!_PyDictOrValues_IsValues(dorv));
>     return dorv.dict;
> }
274,276c400,404
< // Access macro to the members which are floating "behind" the object
< #define _PyHeapType_GET_MEMBERS(etype) \
<     ((PyMemberDef *)(((char *)etype) + Py_TYPE(etype)->tp_basicsize))
---
> static inline void
> _PyDictOrValues_SetValues(PyDictOrValues *ptr, PyDictValues *values)
> {
>     ptr->values = ((char *)values) - 1;
> }
278c406
< PyAPI_FUNC(PyObject *) _PyObject_LookupSpecial(PyObject *, PyObject *);
---
> #define MANAGED_WEAKREF_OFFSET (((Py_ssize_t)sizeof(PyObject *))*-4)
280,305c408,410
< /* C function call trampolines to mitigate bad function pointer casts.
<  *
<  * Typical native ABIs ignore additional arguments or fill in missing
<  * values with 0/NULL in function pointer cast. Compilers do not show
<  * warnings when a function pointer is explicitly casted to an
<  * incompatible type.
<  *
<  * Bad fpcasts are an issue in WebAssembly. WASM's indirect_call has strict
<  * function signature checks. Argument count, types, and return type must
<  * match.
<  *
<  * Third party code unintentionally rely on problematic fpcasts. The call
<  * trampoline mitigates common occurences of bad fpcasts on Emscripten.
<  */
< #if defined(__EMSCRIPTEN__) && defined(PY_CALL_TRAMPOLINE)
< #define _PyCFunction_TrampolineCall(meth, self, args) \
<     _PyCFunctionWithKeywords_TrampolineCall( \
<         (*(PyCFunctionWithKeywords)(void(*)(void))meth), self, args, NULL)
< extern PyObject* _PyCFunctionWithKeywords_TrampolineCall(
<     PyCFunctionWithKeywords meth, PyObject *, PyObject *, PyObject *);
< #else
< #define _PyCFunction_TrampolineCall(meth, self, args) \
<     (meth)((self), (args))
< #define _PyCFunctionWithKeywords_TrampolineCall(meth, self, args, kw) \
<     (meth)((self), (args), (kw))
< #endif // __EMSCRIPTEN__ && PY_CALL_TRAMPOLINE
---
> extern PyObject ** _PyObject_ComputedDictPointer(PyObject *);
> extern void _PyObject_FreeInstanceAttributes(PyObject *obj);
> extern int _PyObject_IsInstanceDictEmpty(PyObject *);
306a412,413
> PyAPI_FUNC(PyObject *) _PyObject_LookupSpecial(PyObject *, PyObject *);
> 
